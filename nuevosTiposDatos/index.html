<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	
	<script type="text/javascript">
		/*********** SYMBOLOS *******************************
						
		LOS SIMBOLOS SON PROPIEDADES PRIVADAS O IDENTIFICADORES DE REFERENCIAS UNICAS

		NOS PUEDEN SERVIR CUANDO CREAMOS OBJETOS CON PROPIEDADES PRIVADAS UNICAS
		para evitar colisiones entre propiedades que pudieramos sobreescribir

		nota deberian ser identificadores y no deberian cambiar por eso se definen con "const"

		 */
		/*let id = "hola";
		let id2 = "hola";

		console.log(id===id2); //true

		let id3 = Symbol("id");
		let id4 = Symbol("id");

		console.log(id3===id4); //false
		console.log(id3===id4); //false
		console.log(id3,id4);
		console.log(typeof id3,typeof id4);

		// const NOMBRE = Symbol();
		// const SALUDAR = Symbol();
		 
		const NOMBRE = Symbol("nombre");
		const SALUDAR = Symbol("saludar");

		const persona = {
			[NOMBRE]:"Nestor",
			edad:25
		}		

		console.log(persona);

		persona.NOMBRE = "Ignacio";

		console.log(persona);
		console.log(persona.NOMBRE); //Ignacio
		console.log(persona[NOMBRE]); //Nestor

		persona[SALUDAR] = function(){
			console.log("HOLA");
		};

		console.log(persona);
		persona[SALUDAR]();

		for(let propiedad in persona){
			console.log(propiedad);
			console.log(persona[propiedad]);
		}
		//edad 25 NOMBRE Ignacio
		//no nos muestra los symbolos
		//
		
		console.log(Object.getOwnPropertySymbols(persona));

		console.clear();*/


		/*********** SET *******************************
			es una estructura de un array pero con datos unicos
			alamcena valores que no sean repetidos pero primitivos
		*/
	
		/*const set = new Set([1,2,3,4,1,5,true,false,false,{},{},"hola","HoLA"]);
		
		console.log(set);
		console.log(set.size);

		const set2 = new Set();
		set2.add(1);
		set2.add(2);
		set2.add(2);
		set2.add(3);
		set2.add(true);
		set2.add(false);
		set2.add(true);
		set2.add({});

		console.log(set2);
		console.log(set2.size);		

		/*para recorrer*/
		/*console.log("SET 1 con for of");
		for(item of set){
			console.log(item);
		}

		console.log("SET 2 con for each");
		set2.forEach((item)=>{
			console.log(item);
		});

		/*para mostrar el valor en la posicion*/
		/*let arr = Array.from(set);
		console.log(arr);
		console.log(arr[0]);
		console.log(arr[9]);

		/*si queremos eliminar un elemento*/
		/*set.delete("HoLA");
		console.log(set);

		/*para verificar si un elemento existe*/
		/*console.log(set.has("hola"));
		console.log(set.has(19));

		/*para limpiar el set*/
		/*set2.clear();
		console.log(set2);


		console.clear();*/



		/*********** MAP *******************************
			es una estructura de un objeto que nos sirven para almacenar valores asociados			
		*/

	   /*const mapa = new Map();
	    mapa.set("nombre", "Jon");
	    mapa.set("apellido", "MirCha");
	    mapa.set("edad", 35);

	    console.log(mapa);
	    console.log(mapa.size);
	    console.log(mapa.has("correo"));
	    console.log(mapa.has("nombre"));
	    console.log(mapa.get("nombre"));
	    mapa.set("nombre", "Jonathan MirCha");
	    console.log(mapa.get("nombre"));
	    mapa.delete("apellido");

	    mapa.set(19, "diecinueve");
	    mapa.set(false, "falso");
	    mapa.set({}, {});
	    console.log(mapa);

	    for (let [key, value] of mapa) {
	      console.log(`Llave: ${key}, Valor:${value}`);
	    }

	    const mapa2 = new Map([
	      ["nombre", "kEnAi"],
	      ["edad", 7],
	      ["animal", "perro"],
	      [null, "nulo"]
	    ]);

	    console.log(mapa2);

	    const llavesMapa2 = [...mapa2.keys()];
	    const valoresMapa2 = [...mapa2.values()];

	    console.log(llavesMapa2);
	    console.log(valoresMapa2);

	    console.clear();*/




	     /* ********** WeakSets & WeakMaps - ********** 
		son set debiles y mapas debiles
		pero les quitan algunas caracteristicas
		y solo aceptan referencias debiles como ser objetos nada mas {}
		lo bueno de estos datos es que cuando los datos internos se vuelven nulos entonces automaticamente es como que la memoria del navegador de limpiara sin necesidad de que nosotros estemos yendo a limpiar el cache
	     */

	    /* //const ws = new WeakSet([1, 2, 3, 3, 4, 5, true, false, false, {}, {}, "hola", "HOla"]);
	    const ws = new WeakSet();

	    let valor1 = { "valor1": 1 };
	    let valor2 = { "valor2": 2 };
	    let valor3 = { "valor3": 3 };

	    ws.add(valor1);
	    ws.add(valor2);

	    console.log(ws);

	    console.log(ws.has(valor1));
	    console.log(ws.has(valor3));

	    ws.delete(valor2);
	    console.log(ws);

	    ws.add(valor2);
	    ws.add(valor3);
	    console.log(ws);

	    setInterval(() => console.log(ws), 1000);

	    setTimeout(() => {
	      valor1 = null;
	      valor2 = null;
	      valor3 = null;
	    }, 5000); */

	    /* const wm = new WeakMap([
	      ["nombre", "kEnAi"],
	      ["edad", 7],
	      ["animal", "perro"],
	      [null, "nulo"]
	    ]); */

	    /* const wm = new WeakMap();
	    let llave1 = {};
	    let llave2 = {};
	    let llave3 = {};

	    wm.set(llave1, 1);
	    wm.set(llave2, 2);
	    console.log(wm);

	    console.log(wm.has(llave1));
	    console.log(wm.has(llave3));

	    console.log(wm.get(llave1));
	    console.log(wm.get(llave2));
	    console.log(wm.get(llave3));

	    wm.delete(llave2);
	    console.log(wm);

	    wm.set(llave2, 2)
	    wm.set(llave3, 3)
	    console.log(wm);

	    setInterval(() => console.log(wm), 1000);

	    setTimeout(() => {
	      llave1 = null;
	      llave2 = null;
	      llave3 = null;
	    }, 5000); */



/* **********   Iterables & Iterators  ********** 
	iterable es el elemento el cual su contenido se puede recorrer
	iterador apuntador o ese mecanismo que esta recorriendo los elementos (destructuracion-for....)
*/
    /* const iterable = [1, 2, 3, 4, 5];
    //const iterable = "Hola Mundo";
    //const iterable = new Set([1, 2, 3, 3, 4, 5]);
    //const iterable = new Map([["nombre", "jon"], ["edad", 35]]);

    //Accedemos al iterador del iterable
    const iterador = iterable[Symbol.iterator]();

    console.log(iterable);
    console.log(iterador);
    //console.log(iterador.next());
    //console.log(iterador.next());
    //console.log(iterador.next());
    //console.log(iterador.next());
    //console.log(iterador.next());
    //console.log(iterador.next());

    let next = iterador.next();

    while (!next.done) {
      console.log(next.value);
      next = iterador.next();
    } */






    /* **********Generators  ******** 
	son la manera de volver funciones iterables
	osea que una funcion pueda retornando mas de un return conforme nosotros vayamos colocando next y enves de return es yield
    */
   /*
    function* iterable() {
      yield "hola";
      console.log("Hola consola");
      yield "hola 2";
      console.log("Seguimos con más instrucciones de nuestro código");
      yield "hola 3";
      yield "hola 4";
    }

    let iterador = iterable();
    //console.log(iterador.next());
    //console.log(iterador.next());
    //console.log(iterador.next());
    //console.log(iterador.next());
    //console.log(iterador.next());

    for (let y of iterador) {
      console.log(y);
    }

    arr = [...iterable()];
    console.log(arr); //solo agrega los valores de los yields en el array

    function cuadrado(valor) {
      setTimeout(() => {
        return console.log({ valor, resultado: valor * valor })
      }, Math.random() * 1000);
    }

    function* generador() {
      console.log("Inicia Generator");
      yield cuadrado(0);
      yield cuadrado(1);
      yield cuadrado(2);
      yield cuadrado(3);
      yield cuadrado(4);
      yield cuadrado(5);
      console.log("Termina Generator");
    }

    let gen = generador();

    for (let y of gen) {
      //console.log(y);  //esta linea comentamos porque de otra forma nos va imprimiendo undefined
      //aqui tenemos un ejemplo de asincronia no bloqueante ya que se van ejecutando conforme van acabando 
    } 
*/





 /* **********  Proxies    
	son una manera de declarar un objeto literal a partir de otro
	con la particularidad que tiene su manejador que nos servira para hacer cualquier tipo de validaciones que tenga el objeto padre
 ********** */
    /*const persona = {
      nombre: "",
      apellido: "",
      edad: 0
    }

    const manejador = {
      set(obj, prop, valor) {
      	//sino tuviera esta validacion entonces podriamos agregar cualquier propiedad en el objeto hijo y esto repercutiria en que tambien se cree la propiedad en el obj padre
        if (Object.keys(obj).indexOf(prop) === -1) {
          return console.error(`La propiedad "${prop}" no existe en el objeto persona.`);
        }

        if (
          (prop === "nombre" || prop === "apellido") &&
          !(/^[A-Za-zÑñÁáÉéÍíÓóÚúÜü\s]+$/g.test(valor))
        ) {
          return console.error(`La propiedad "${prop}"" sólo acepta letras y espacios en blanco`);
        }
        obj[prop] = valor;
      }
    }

    const jon = new Proxy(persona, manejador);
    jon.nombre = "Jon";
    jon.apellido = "MirCha";
    jon.edad = 35;
    jon.twitter = "@jonmircha";
    console.log(jon);

    console.log(persona); */


    /* **********  Propiedades Dinámicas     
	es una forma de crear propiedades dinamicas en objetos
	nos puede servir cuando recorremos un objeto que pueda estar programado con solo crear propiedades de archivos (ejemplo de las vistas y un archivo index de las rutas) y asi no estar creando cada una de las propiedades del objeto individual por cada vista
     ********** */
         let aleatorio = Math.round(Math.random() * 100 + 5);
        const objUsuarios = {
          propiedad: "Valor",
          [`id_${aleatorio}`]: "Valor Aleatorio"
        };
        console.log(objUsuarios);

        const usuarios = ["Jon", "Irma", "Miguel", "Kala", "kEnAi"];
        usuarios.forEach((usuario, index) => objUsuarios[`id_${index}`] = usuario);

        console.log(objUsuarios); 










	</script>
</body>
</html>